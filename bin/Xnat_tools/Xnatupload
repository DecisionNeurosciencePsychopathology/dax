#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Download almost everything you need from Xnat

@author: Benjamin Yvernault, Electrical Engineering, Vanderbilt University

'''

import os
import sys
import csv
import glob
import logging
import getpass
from dax import XnatUtils
from datetime import datetime

########### VARIABLES ###########
DEFAULT_NOTE='Xnatupload'
DEFAULT_CSV_LIST=['object_type','project_id','subject_label','session_type','session_label', 'as_label', 'as_type', 'as_description','quality','resource','fpath']
SCAN_HEADER=['object_type','project_id','subject_label','session_type','session_label', 'ID', 'type', 'series_description','quality']
ASSESSOR_HEADER=['object_type','project_id','subject_label','session_type','session_label', 'label', 'proctype', 'procstatus','qcstatus']
DEFAULT_LABELS_DICT={'Project':0, 'Subject':1, 'Session':2, 'Scan':3, 'Scan Type':4, 'Scan Series Description':5, 'Resource':6}
MR_SCAN_FOR_MODALITY=['RT'] #No ScanData on XNAT for those modalities, using mr by default
MODALITY_DICT={'CT':'xnat:ctSessionData','MR': 'xnat:mrSessionData','PET': 'xnat:petSessionData', 'EPS': 'xnat:epsSessionData', 'DX': 'xnat:dxSessionData', 'RT': 'xnat:rtSessionData', 'EEG': 'xnat:eegSessionData', 'HD': 'xnat:hdSessionData', 'DX3DCRANIOFACIAL': 'xnat:dx3DCraniofacialSessionData', 'ECG': 'xnat:ecgSessionData', 'OTHERDICOM': 'xnat:otherDicomSessionData', 'RF': 'xnat:rfSessionData', 'XA3D': 'xnat:xa3DSessionData', 'ESV': 'xnat:esvSessionData', 'XC': 'xnat:xcSessionData', 'XA': 'xnat:xaSessionData', 'MEG': 'xnat:megSessionData', 'IO': 'xnat:ioSessionData', 'CR': 'xnat:crSessionData', 'GM': 'xnat:gmSessionData', 'GMV': 'xnat:gmvSessionData', 'ES': 'xnat:esSessionData', 'OPT': 'xnat:optSessionData', 'MG': 'xnat:mgSessionData', 'US': 'xnat:usSessionData', 'XCV': 'xnat:xcvSessionData', 'SM': 'xnat:smSessionData', 'OP': 'xnat:opSessionData'}
MODALITY_INFO={'CT'               : 'An event in which CT scans are obtained on a subject',
               'MR'               : 'An event in which MR scans are obtained on a subject',
               'PET'              : 'An event in which PET scans are obtained on a subject',
               'EPS'              : 'Cardiac Electrophysiology Session',
               'DX'               : 'An event in which Digital Radiography scans are obtained on a subject',
               'RT'               : 'Radiotherapy Session',
               'EEG'              : 'Electroencephalography Session',
               'HD'               : 'Hemodynamic Session',
               'DX3DCRANIOFACIAL' : 'X-Ray 3D Craniofacial Session',
               'ECG'              : 'Electrocardiography Session',
               'OTHERDICOM'       : 'DICOM study of undetermined type',
               'RF'               : 'Radiofluoroscopy Session',
               'XA3D'             : 'X-Ray 3D Angiography Session',
               'ESV'              : 'Video Endoscopy Session',
               'XC'               : 'Visible Light Photography Session',
               'XA'               : 'An event in which X-ray Angiography scans are obtained on a subject',
               'MEG'              : 'Magnetoencephalography Session',
               'IO'               : 'Intraoral Radiography Session',
               'CR'               : 'Computed Radiography Session',
               'GM'               : 'Visible Light Microscopy Session',
               'GMV'              : 'Video Microscopy Session',
               'ES'               : 'Visible Light Endoscopy Session',
               'OPT'              : 'Ophthalmic Tomography Session',
               'MG'               : 'Digital Mammography Session',
               'US'               : 'Ultrasound Session',
               'XCV'              : 'Video Photography Session',
               'SM'               : 'Visible Light Slide-Coordinates Microscopy Session',
               'OP'               : 'Ophthalmic Photography Session'}

DEFAULT_ARGUMENTS = {'username': None, 'outputfile': None, 'force': False, 'session_type': None,
                     'printmodality': False, 'csvfile': None, 'host': None, 'deleteAll': False,
                     'report': False, 'delete': False}
DESCRIPTION = """What is the script doing :
   * Upload data to XNAT following the csv file information.
     csv header: object_type,project_id,subject_label,session_type,session_label,as_label,as_type,as_description,quality,resource,fpath
     IMPORTANT: YOU NEED TO CREATE THE PROJECT ON XNAT BEFORE.

Examples:
   * See Session type: Xnatupload --printmodality
   * Simple upload: Xnatupload -c upload_sheet.csv
   * Upload everything with a session type: Xnatupload -c upload_sheet.csv --sess PET
   * Check the upload: Xnatupload -c upload_sheet.csv --report
   * Force upload: Xnatupload -c upload_sheet.csv --force
   * Upload with delete resource before uploading: Xnatupload -c upload_sheet.csv --delete
   * Upload with delete every resources for the object (SCAN/ASSESSOR) before uploading: Xnatupload -c upload_sheet.csv --deleteAll
"""

########### USEFUL FUNCTIONS ###########
def setup_info_logger(name):
    """
    Using logger for the executables output.
     Setting the information for the logger.

    :param name: Name of the logger
    :return: logging object
    """
    if OPTIONS.outputfile:
        handler = logging.FileHandler(OPTIONS.outputfile, 'w')
    else:
        handler = logging.StreamHandler()

    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    logger.addHandler(handler)
    return logger

def get_option_list(option):
    """
    Method to convert option value to a list, None if empty, all if all selected

    :param option: string representing the option
    :return: None if empty, 'all' if all selected, list otherwise
    """
    if not option:
        return None
    elif option == 'all':
        return 'all'
    elif option == 'nan':
        return None
    else:
        return option.split(',')

def extract_obj_one_subject(project, subject, obj_list):
    """
    Method to extract objects for a specific subject from a list

    :param project: project ID on XNAT
    :param subject: subject label on XNAT
    :param obj_list: objects list to filter
    :return: list containing only the desired objects
    """
    return filter(lambda x: x['subject_label'] == subject and x['project_id'] == project, obj_list)

def smaller_str(str_option, size=10, end=False):
    """
    Method to shorten a string into a smaller size

    :param str_option: string to shorten
    :param size: size of the string to keep (default: 10 characters)
    :param end: keep the end of the string visible (default beginning)
    :return: shortened string
    """
    if len(str_option) > size:
        if end:
            return '...%s' % (str_option[-size:])
        else:
            return '%s...' % (str_option[:size])
    else:
        return str_option

def read_csv_for_upload():
    """
    Read the csv describing the data to upload to XNAT

    :return: list of scans and assessors to upload
    """
    scans_list = list()
    asses_list = list()
    res_s_dict = dict()
    res_a_dict = dict()
    subjects_sessions_list = list()
    if os.path.exists(OPTIONS.csvfile):
        LOGGER.info('INFO: Reading CSV -- if you see any warning, it means that the row will not be uploaded.')
        with open(OPTIONS.csvfile, 'rb') as csvfileread:
            csvreader = csv.reader(csvfileread, delimiter=',')
            for index, row in enumerate(csvreader):
                if len(row) < 11:
                    LOGGER.info('WARNING: row '+str(index+1)+' -- not enough column. Check the header needed for Xnatupload.')
                else:
                    if row[0] == 'scan':
                        subjects_sessions_list.append('%s-x-%s' % (row[2], row[4]))
                        if row[1] and row[2] and (OPTIONS.session_type or row[3]) and row[4] and row[5] and row[-2] and row[-1]:
                            if not OPTIONS.session_type and not row[3] in MODALITY_DICT.keys():
                                LOGGER.info('WARNING: row %s -- wrong session type, not defined on XNAT.' % (str(index+1)))
                            else:
                                scan_dict = dict(zip(SCAN_HEADER, row[:9]))
                                scan_dict['label'] = '-x-'.join([row[1], row[2], row[4], row[5]])
                                scans_list.append(scan_dict)
                                res_s_dict = add_resource(res_s_dict, '-x-'.join([row[1], row[2], row[4], row[5]]), row[-2], row[-1])
                        else:
                            LOGGER.info('WARNING: row %s -- an element for one or more columns with the index 2/3/4/5/6/10/11 is empty.' % (str(index+1)))
                    elif row[0] == 'assessor':
                        subjects_sessions_list.append('%s-x-%s' % (row[2], row[4]))
                        if row[1] and row[2] and (OPTIONS.session_type or row[3]) and row[4] and row[5] and row[6] and row[-2] and row[-1]:
                            if not OPTIONS.session_type and not row[3] in MODALITY_DICT.keys():
                                LOGGER.info('WARNING: row %s -- wrong session type, not defined on XNAT.' % (str(index+1)))
                            else:
                                asses_list.append(dict(zip(ASSESSOR_HEADER, row[:9])))
                                res_a_dict = add_resource(res_a_dict, row[5], row[-2], row[-1])
                        else:
                            LOGGER.info('WARNING: row %s -- an element for one or more columns with the index 2/3/4/5/6/7/10/11 is empty.' % (str(index+1)))
                    else:
                        LOGGER.info('WARNING: row %s -- does not start with "scan" or "assessor".' % (str(index+1)))
        LOGGER.info('INFO: Reading CSV DONE\n')
        #Checking session:
        check_session_id(subjects_sessions_list)
        #Generating SNAPSHOTS for assessor PDF:
        LOGGER.info('INFO:Generating snapshots for assessor...')
        res_a_dict = generate_previews(res_a_dict)
        #Combine the resources dictionaries to each lists:
        scans_list = combine_obj_resource(scans_list, res_s_dict)
        asses_list = combine_obj_resource(asses_list, res_a_dict)
    else:
        LOGGER.info('ERROR: file %s not found. Check if the file exists.' % (OPTIONS.csvfile))
        sys.exit()
    return scans_list, asses_list

def check_session_id(subjects_sessions_list):
    """
    Check that the session labels given are unique before uploading
     XNAT doesn't allow two sessions to be named with the same label

    :param subjects_sessions_list: list of subjects/sessions labels
    :return: None
    """
    sessions_list = list()
    for ssdict in set(subjects_sessions_list):
        if ssdict.split('-x-')[1] in sessions_list:
            LOGGER.info('XNAT ERROR: xnatupload stop.')
            LOGGER.info('  The csv provided possesses some rows with the same session label for two different subjects.')
            LOGGER.info('  Session label needs to be unique. Two subject can not have a session with the same label.')
            LOGGER.info('  Please fix the csv and call again Xnatupload.')
            sys.exit()
        else:
            sessions_list.append(ssdict.split('-x-')[1])

def add_resource(rs_dict, label, resource_label, fpath):
    """
    Adding resources to the dictionary

    :param rs_dict: dictionary of resource for the objects to upload
    :param label: label of the object to add a resource
    :param resource_label: resource label of the new resource
    :param fpath: path to the resource to add
    :return: list of object with the resources specified by resource
    """
    if label in rs_dict.keys():
        resources_dict = rs_dict[label]
        if resource_label in resources_dict.keys():
            resources_dict[resource_label].append(fpath)
        else:
            resources_dict[resource_label] = [fpath]
        rs_dict[label] = resources_dict
    else:
        rs_dict[label] = {resource_label:[fpath]}
    return rs_dict

def combine_obj_resource(obj_list, r_dict):
    """
    Combine the object list and the resource dictionary

    :param obj_list: list of object to upload
    :param r_dict: dictionary of resource for the objects to upload
    :return: list of object with the resources specified by resource
    """
    #Unique list of dictionaries:
    obj_list = {v['label']:v for v in obj_list}.values()
    for object_dict in obj_list:
        object_dict['resource'] = r_dict[object_dict['label']]
    return obj_list

def generate_previews(ra_dict):
    """
    Generate Preview for an assessor with a PDF

    :param ra_dict: dictionary of resource attributes for the assessor to uplaod
    :return: new dictionary containing snapshots original and preview
    """
    for label, resource_dict in ra_dict.items():
        if 'PDF' in resource_dict.keys():
            pdf_path = check_pdfpath(resource_dict['PDF'], label)
            if not pdf_path:
                LOGGER.info(' WARNING: generate_previews -- %s -- No proper PDF file found. No snapshots will be generated.' % (label))
            else:
                #SNAPSHOTS : create it in the /tmp/ folder under the assessor name
                tmp_path = os.path.join('/tmp', '%s_snapshots' % (label))
                if not os.path.exists(tmp_path):
                    os.makedirs(tmp_path)
                #Make the snapshots for the assessors with ghostscript
                snapshot_original = os.path.join(tmp_path, 'snapshot_original.png')
                os.system('gs -q -o %s -sDEVICE=pngalpha -dLastPage=1 %s' % (snapshot_original, pdf_path))
                #Name of the preview snapshot
                if os.path.exists(snapshot_original):
                    snapshot_preview = os.path.join(tmp_path, 'snapshot_preview.png')
                    #Make the snapshot_thumbnail
                    os.system('convert %s -resize x200 %s' % (snapshot_original, snapshot_preview))
                if not os.path.exists(snapshot_original) or not os.path.exists(snapshot_preview):
                    LOGGER.info(' WARNING: generate_previews -- %s -- Failed to create preview/original for snapshots of PDF.' % (label))
                else:
                    if 'SNAPSHOTS' in resource_dict.keys():
                        resource_dict['SNAPSHOTS'].append(snapshot_original)
                        resource_dict['SNAPSHOTS'].append(snapshot_preview)
                    else:
                        resource_dict['SNAPSHOTS'] = [snapshot_original, snapshot_preview]
    return ra_dict

def check_pdfpath(pdf_paths_list, label):
    """
    Check that the PDF is a proper .pdf file

    :param pdfpath_list: list of pdf path
    :return: the path to a PDF or None if no PDF found
    """
    if len(pdf_paths_list) > 1:
        LOGGER.info(' WARNING: generate_previews -- %s --more than one PDF file paths given, the first one found will be used to create the snapshots.' % (label))
    for ppath in pdf_paths_list:
        if os.path.isfile(ppath) and ppath.endswith('.pdf'):
            return ppath
        if os.path.isdir(ppath):
            pdfs_list = glob.glob(os.path.join(ppath, '*.pdf'))
            if pdfs_list:
                return pdfs_list[0]
    return None

def read_csv():
    """
    Read the csv describing the data to upload to XNAT for the report

    :return: list of scans and assessors to upload
    """
    scans_asses_list = list()
    if os.path.exists(OPTIONS.csvfile):
        with open(OPTIONS.csvfile, 'rb') as csvfileread:
            csvreader = csv.reader(csvfileread, delimiter=',')
            for index, row in enumerate(csvreader):
                if len(row) < 11:
                    LOGGER.info('WARNING: row %s -- not enough column. Check the header needed for Xnatupload.' % (str(index+1)))
                else:
                    if row[0] in ['scan', 'assessor']:
                        scans_asses_list.append(dict(zip(DEFAULT_CSV_LIST, row)))
                    else:
                        LOGGER.info('WARNING: row %s -- does not start with "scan" or "assessor".' % (str(index+1)))
    else:
        LOGGER.info('ERROR: file %s not found. Check if the file exists.' % (OPTIONS.csvfile))
        sys.exit()
    return scans_asses_list

def get_files_in_folder(folder, label=''):
    """
    Get all the files and subfolder inside a folder

    :param folder: folder path to search
    :param label: prefix path to happen to the path
    :return: list of files/folder
    """
    f_list = list()
    for fpath in os.listdir(folder):
        ffpath = os.path.join(folder, fpath)
        if os.path.isfile(ffpath):
            fpath = check_image_format(fpath)
            if label:
                filename = os.path.join(label,fpath)
            else:
                filename = fpath
            f_list.append(filename)
        else:
            label = os.path.join(label, fpath)
            f_list.extend(get_files_in_folder(ffpath, label))
    return f_list

def check_folder_resources(resource_obj, folder):
    """
    Check that the files don't exist on the XNAT resource before uploading

    :param resource_obj: pyxnat resource Eobject
    :param folder: folder containing the images
    :return: True if not upload, False otherwise
    """
    for fpath in get_files_in_folder(folder): #RECURSIVELY
        if resource_obj.file(fpath).exists():
            if OPTIONS.force:
                resource_obj.file(fpath).delete()
            else:
                LOGGER.info('     - WARNING: filepath %s -- already found on XNAT. Use --force to upload this file.' % (fpath))
                return True
    return False

def check_image_format(fpath):
    """
    Check that the NII and REC are gzip before uploading

    :param fpath: path that need to be check
    :return: path for the image
    """
    if fpath.endswith('.nii') or fpath.endswith('.rec'):
        os.system('gzip %s' % (fpath))
        fpath = '%s.gz' % (fpath)
    return fpath

def is_file(fpath):
    """
    Verify if the path is a file and if it's a folder,
     if there is only one file in the folder, return the file

    :param fpath: path that need to be check
    :return: True if it's a file or False otherwise, path of the file
    """
    if os.path.isfile(fpath):
        return True, fpath
    else: #It's a folder, check if only one file in it:
        if len(glob.glob(os.path.join(fpath, '*'))) == 1:
            return True, glob.glob(os.path.join(fpath,'*'))[0]
        else:
            if fpath[-1] == '/':
                fpath = fpath[:-1]
            return False, fpath

########### REPORT ###########
def print_report():
    """
    Print report on the upload to verify the options from the user

    :param options: options set by the user
    :return: None
    """
    scans_assessors_list = read_csv()
    LOGGER.info('\n----------------------------------')
    #Display:
    LOGGER.info('Report information about uploading :')
    LOGGER.info('Date: %s' % (str(datetime.now())))
    LOGGER.info('===================================================================')
    LOGGER.info('List of the data found in the csv that need to be upload :')
    LOGGER.info('-----------------------------------------')
    LOGGER.info('%*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s ' % (-10, 'ObjectType',
                                                                                      -10, 'Project',
                                                                                      -10, 'Subject',
                                                                                      -10, 'SessType',
                                                                                      -15, 'Session',
                                                                                      -30, 'Label',
                                                                                      -15, 'Type',
                                                                                      -15,'Description',
                                                                                      -15, 'Quality',
                                                                                      -10, 'Resource',
                                                                                      -58, 'file(s)/folder'))
    LOGGER.info('----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------')
    for scan_assessor in sorted(scans_assessors_list):
        objt = smaller_str(scan_assessor['object_type'])
        proj = smaller_str(scan_assessor['project_id'])
        subj = smaller_str(scan_assessor['subject_label'])
        setype = smaller_str(scan_assessor['session_type'])
        sess = smaller_str(scan_assessor['session_label'], size=15)
        as_label = smaller_str(scan_assessor['as_label'], size=27)
        as_type = smaller_str(scan_assessor['as_type'], size=12)
        as_des = smaller_str(scan_assessor['as_description'], size=12)
        quality = smaller_str(scan_assessor['quality'], size=12)
        resource = smaller_str(scan_assessor['resource'])
        filepath = get_proper_str(scan_assessor['fpath'], end=True)
        LOGGER.info('%*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s | %*s ' % (-10, objt,
                                                                                          -10, proj,
                                                                                          -10, subj,
                                                                                          -10, setype,
                                                                                          -15, sess,
                                                                                          -30, as_label,
                                                                                          -15, as_type,
                                                                                          -15, as_des,
                                                                                          -15, quality,
                                                                                          -10, resource,
                                                                                          -58, filepath))
    LOGGER.info('\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n')
    LOGGER.info('INFOS on header:')
    LOGGER.info('  #Description = Job status for assessor or series description for scan')
    LOGGER.info('  #Quality     = Job quality control for assessor or quality for scan (usable/unusable/questionable)')
    LOGGER.info('WARNINGS: ')
    LOGGER.info('  #If one of the column is empty for Project/Subject/SessType/Session/Label/resource, the resource will not get upload.')
    LOGGER.info('  #By default, quality is set to questionable for scan and  Needs QA for assessor.')
    LOGGER.info('  #By default, Description (job status) for an assessor will be set to COMPLETE.')
    LOGGER.info('  #IMPORTANT: a session label needs to be unique for a project.')
    LOGGER.info('P.S : Please check that the REC or NII image type that you upload are compressed (.rec/.nii), please compress them in .gz like "file.nii.gz".')

def print_modality():
    """
    Print modality available for upload to XNAT using Xnatupload

    :return: None
    """
    print 'INFO: Printing the modality available for a Session'
    for mod_key in sorted(MODALITY_DICT, key=lambda key: MODALITY_DICT[mod_key]):
        print ' %*s : %*s ' % (-17, mod_key, -30, MODALITY_INFO[mod_key])
    print '==================================================================='

########### CREATE XNAT OBJ ###########
def get_xnat_obj(obj_dict):
    """
    Generate the tree architecture for the object or select the xnat object

    :param obj_dict: dictionary for attributes of a XNAT object
    :return: None
    """
    new_obj = False
    obj = None
    #Project:
    project_obj = XNAT.select('/project/%s' % (obj_dict['project_id']))
    if not project_obj.exists():
        LOGGER.info('WARNING: Project %s does not exists on XNAT.' % (obj_dict['project_id']))
        return obj, new_obj
    #Subject:
    subject_obj = project_obj.subject(obj_dict['subject_label'])
    if not subject_obj.exists():
        subject_obj.insert()
    #Session:
    session_obj = subject_obj.experiment(obj_dict['session_label'])
    if not session_obj.exists():
        if OPTIONS.session_type:
            session_obj.create(experiments=MODALITY_DICT[OPTIONS.session_type])
        else:
            session_obj.create(experiments=MODALITY_DICT[obj_dict['session_type']])
        date = datetime.now()
        session_obj.attrs.set('xnat:experimentdata/date','%s-%s-%s' % (str(date.year), str(date.month), str(date.day)))
    #Scan
    if obj_dict['object_type'] == 'scan':
        obj = session_obj.scan(obj_dict['ID'])
        if not obj.exists():
            obj = create_scan(obj, obj_dict)
            new_obj = True
    elif obj_dict['object_type'] == 'assessor':
        obj = session_obj.assessor(obj_dict['label'])
        if not obj.exists():
            obj = create_assessor(obj, obj_dict)
            new_obj = True
        else:
            set_attrs_assessors(obj, obj_dict)
    else:
        LOGGER.info('WARNING: object_type not recognize between scan and assessor.')

    return obj, new_obj

def create_scan(scan, scan_dict):
    """
    Create the scans on XNAT

    :param scan: pyxnat scan Eobject
    :param scan_dict: attributes to set for the scan
    :return: pyxnat scan Eobject
    """
    if OPTIONS.session_type:
        if OPTIONS.session_type in MR_SCAN_FOR_MODALITY:
            scan.create(scans='xnat:mrScanData')
        else:
            xsitype = 'xnat:%sScanData' % (OPTIONS.session_type.lower())
            scan.create(scans=xsitype)
    else:
        if scan_dict['session_type'] in MR_SCAN_FOR_MODALITY:
            scan.create(scans='xnat:mrScanData')
        else:
            xsitype = 'xnat:%sScanData' % (scan_dict['session_type'].lower())
            scan.create(scans=xsitype)
    #set attributes
    scan.attrs.mset({'type':scan_dict['type'],
                     'series_description':scan_dict['series_description'],
                     'quality':scan_dict['quality'],
                     'note':DEFAULT_NOTE})
    return scan

def create_assessor(assessor, assessor_dict):
    """
    Create the assessors on XNAT

    :param assessor: pyxnat assessor Eobject
    :param assessor_dict: attributes to set for the assessors
    :return: pyxnat assessor Eobject
    """
    now = datetime.now()
    today = str(now.year)+'-'+str(now.month)+'-'+str(now.day)
    if assessor_dict['proctype'].lower() in ['freesurfer', 'fs'] and XnatUtils.has_fs_datatypes(XNAT):
        assessor.create(assessors='fs:fsData', **{'fs:fsData/fsversion':'0'})
        assessor.attrs.mset({XnatUtils.DEFAULT_FS_DATATYPE+'/procstatus': assessor_dict['procstatus'],
                             XnatUtils.DEFAULT_FS_DATATYPE+'/validation/status':assessor_dict['qcstatus'],
                             XnatUtils.DEFAULT_FS_DATATYPE+'/proctype':'FreeSurfer',
                             XnatUtils.DEFAULT_FS_DATATYPE+'/date':today})
    elif XnatUtils.has_genproc_datatypes(XNAT):
        assessor.create(assessors='proc:genProcData')
        assessor.attrs.mset({XnatUtils.DEFAULT_DATATYPE+'/procstatus': assessor_dict['procstatus'],
                             XnatUtils.DEFAULT_DATATYPE+'/validation/status':assessor_dict['qcstatus'],
                             XnatUtils.DEFAULT_DATATYPE+'/proctype':assessor_dict['proctype'],
                             XnatUtils.DEFAULT_DATATYPE+'/date':today})
    return assessor

def set_attrs_assessors(assessor, assessor_dict):
    """
    Set the attributes for the assessors

    :param assessor: pyxnat assessor Eobject
    :param assessor_dict: attributes to set for the assessors
    :return: None
    """
    if assessor_dict['proctype'].lower() in ['freesurfer','fs']:
        assessor.attrs.mset({XnatUtils.DEFAULT_FS_DATATYPE+'/procstatus':assessor_dict['procstatus'],
                             XnatUtils.DEFAULT_FS_DATATYPE+'/validation/status':assessor_dict['qcstatus']})
    else:
        assessor.attrs.mset({XnatUtils.DEFAULT_DATATYPE+'/procstatus':assessor_dict['procstatus'],
                             XnatUtils.DEFAULT_DATATYPE+'/validation/status':assessor_dict['qcstatus']})

######################################### MAIN FUNCTION TO UPLOAD ###############################################
def upload_data_xnat():
    """
    Main function to upload data from XNAT
       looping over the project/subject to be in order

    :return: None
    """
    #Extract list of subject to download in order:
    proj_subj_list = list()
    if SCANS:
        proj_subj_list.extend([s['project_id']+'-x-'+s['subject_label'] for s in SCANS])
    if ASSESSORS:
        proj_subj_list.extend([s['project_id']+'-x-'+s['subject_label'] for s in ASSESSORS])
    proj_subj_list = set(proj_subj_list) #unique list of identifiant
    #Number of subjects
    number = len(proj_subj_list)
    #Download:
    LOGGER.info('INFO: Uploading data for each pair project/subject..')
    for index, ps in enumerate(sorted(proj_subj_list)):
        project = ps.split('-x-')[0]
        subject = ps.split('-x-')[1]
        LOGGER.info(' * %s/%s subjects -- Pair Project/Subject : %s/%s' % (str(index+1), str(number), project, subject))
        ##SCAN##
        for scan in extract_obj_one_subject(project, subject, SCANS):
            scan_obj, _ = get_xnat_obj(scan)
            if scan_obj:
                LOGGER.info('  +session %s -- scan %s -- type: %s -- series description: %s -- quality: %s' % (scan['session_label'],
                                                                                                               scan['ID'],
                                                                                                               scan['type'],
                                                                                                               scan['series_description'],
                                                                                                               scan['quality']))
                upload_resources(scan_obj, scan)
        ##ASSESSOR##
        for assessor in extract_obj_one_subject(project, subject, ASSESSORS):
            assessor_obj, _ = get_xnat_obj(assessor)
            if assessor_obj:
                LOGGER.info('  +proc %s -- job status: %s -- QC status: %s' % (assessor['label'],
                                                                               assessor['procstatus'],
                                                                               assessor['qcstatus']))
                upload_resources(assessor_obj, assessor)

########### UPLOAD RESOURCES ###########
def upload_resources(obj, obj_dict):
    """
    Method to upload resources

    :param obj: pyxnat Eobject
    :param obj_dict: dictionary describing the pyxnat Eobject
    :return: None
    """
    if OPTIONS.deleteAll:
        delete_all_resources(obj, obj_dict)

    #Upload each resources:
    for resource_label, fpath_list in obj_dict['resource'].items():
        LOGGER.info('   >Resource %s' % (resource_label))
        if resource_label == 'SNAPSHOTS' and obj_dict['object_type'] == 'assessor':
            #Special upload for snapshots for assessor
            upload_snaptshot(obj.out_resource(resource_label), fpath_list)
        else:
            for fpath in fpath_list:
                if not os.path.exists(fpath):
                    LOGGER.info('     - File %s: WARNING -- path not found.' % (fpath))
                else:
                    if obj_dict['object_type'] == 'scan':
                        upload_fpath(obj.resource(resource_label), fpath)
                    else:
                        upload_fpath(obj.out_resource(resource_label), fpath)

def delete_all_resources(obj, obj_dict):
    """
    Method to delete all resources for an object

    :param obj: pyxnat Eobject
    :param obj_dict: dictionary describing the pyxnat Eobject
    :return: None
    """
    if obj_dict['object_type'] == 'scan':
        for resource_label in XnatUtils.list_scan_resources(XNAT, obj_dict['project_id'],
                                                            obj_dict['subject_label'],
                                                            obj_dict['session_label'],
                                                            obj_dict['ID']):
            obj.resource(resource_label).delete()
    else:
        for resource_label in XnatUtils.list_assessor_out_resources(XNAT, obj_dict['project_id'],
                                                                    obj_dict['subject_label'],
                                                                    obj_dict['session_label'],
                                                                    obj_dict['label']):
            obj.out_resource(resource_label).delete()

def upload_fpath(resource_obj, fpath):
    """
    Method to upload a path to a resource

    :param resource_obj: resource object to upload snapshots to
    :param fpath: path to either a folder or file to upload
    :return: None
    """
    #check if the resource exist, if yes remove it
    if OPTIONS.delete and resource_obj.exists():
        resource_obj.delete()
    #Check file path given
    isfile, fpath = is_file(fpath)
    if isfile:
        upload_file(resource_obj, fpath)
    else:
        upload_folder(resource_obj, fpath)

def upload_file(resource_obj, fpath):
    """
    Method to upload a file to a resource

    :param resource_obj: resource object to upload snapshots to
    :param fpath: path to the file to upload
    :return: None
    """
    # upload file to XNAT
    if not resource_obj.file(os.path.basename(fpath)).exists() or OPTIONS.force:
        if resource_obj.file(os.path.basename(fpath)).exists():
            resource_obj.file(os.path.basename(fpath)).delete()
        LOGGER.info('     - File %s: uploading file...' % (os.path.basename(fpath)))
        fpath = check_image_format(fpath)
        resource_obj.file(os.path.basename(fpath)).put(fpath, overwrite=True)
    else:
        LOGGER.info('     - File %s: WARNING -- file found on XNAT. Use --force to upload this file.' % (os.path.basename(fpath)))

def upload_folder(resource_obj, fpath):
    """
    Method to upload a folder to a resource

    :param resource_obj: resource object to upload snapshots to
    :param fpath: path to the folder to upload
    :return: None
    """
    #check all the files if one exist at least:
    if check_folder_resources(resource_obj, fpath):
        LOGGER.info('     - WARNING: files in resource already found on XNAT. Use --force to upload this file.')
    else:
        if not resource_obj.exists(): resource_obj.create()
        filename_zip = resource_obj.label()+'.zip'
        init_dir = os.getcwd()
        #Zip all the files in the directory
        os.chdir(fpath)
        os.system('zip -r %s * > /dev/null' % (filename_zip))
        #upload
        LOGGER.info('     - Folder %s: uploading folder...' % (fpath))
        resource_obj.put_zip(os.path.join(fpath, filename_zip), overwrite=True, extract=True)
        #remove the tmp zip file:
        if os.path.exists(os.path.join(fpath, filename_zip)):
            os.remove(os.path.join(fpath, filename_zip))
        #return to the initial directory:
        os.chdir(init_dir)

def upload_snaptshot(resource_obj, fpath_list):
    """
    Method to upload snapshots to a resource

    :param resource_obj: resource object to upload snapshots to
    :param fpath_list: paths of the files to be uploaded
    :return: None
    """
    #check if the resource exist, if yes remove it
    if OPTIONS.delete and resource_obj.exists():
        resource_obj.delete()
    #Previews
    snapshot_preview = None
    snapshot_original = None
    for fpath in fpath_list:
        #Check file path given
        isfile, fpath = is_file(fpath)
        if isfile:
            if 'snapshot_preview.png' in fpath:
                snapshot_preview = fpath
            elif 'snapshot_original.png' in fpath:
                snapshot_original = fpath
            else:
                upload_file(resource_obj, fpath)
        else:
            upload_folder(resource_obj, fpath)
    #Upload previews
    if snapshot_preview:  resource_obj.file(os.path.basename(snapshot_preview)).put(snapshot_preview, snapshot_preview.split('.')[1].upper(), 'THUMBNAIL', overwrite=True)
    if snapshot_original: resource_obj.file(os.path.basename(snapshot_original)).put(snapshot_original, snapshot_original.split('.')[1].upper(), 'ORIGINAL', overwrite=True)

########### CHECK OPTIONS ###########
def check_options():
    """
    Method to check options given to executables

    :return: True if options are fine, False otherwise
    """
    if OPTIONS.printmodality:
        return True
    if OPTIONS.csvfile:
        if not os.path.exists(OPTIONS.csvfile):
            print 'OPTION ERROR: You used option -c/--csv but the file %s does not exist.' % (OPTIONS.csvfile)
            return False
    else:
        print 'OPTION ERROR: Please provide a csv file with the option -c/--csv.'
        return False

    if OPTIONS.session_type:
        if OPTIONS.session_type not in MODALITY_DICT.keys():
            print 'OPTION ERROR: session type set by user does not exist on XNAT: %s\n' % (OPTIONS.session_type)
            print_modality()
            return False
        else:
            print 'OPTION WARNING: session type set by user. Not using session type in the csv.'
    return True

########### MAIN DISPLAY FUNCTION ###########
def main_display():
    """
    Main display of the executables before any process

    :return: None
    """
    #Display:
    print '################################################################'
    print '#                          XNATUPLOAD                          #'
    print '#                                                              #'
    print '# Developed by the masiLab Vanderbilt University, TN, USA.     #'
    print '# If issues, please start a thread here:                       #'
    print '# https://groups.google.com/forum/#!forum/vuiis-cci            #'
    print '# Usage:                                                       #'
    print '#     Upload data to XNAT following the csv file information   #'
    print '# Parameters :                                                 #'
    if vars(OPTIONS) == DEFAULT_ARGUMENTS:
        print '#     No Arguments given                                       #'
        print '#     See the help bellow or use "Xnatupload -h"               #'
        print '################################################################'
        PARSER.print_help()
        sys.exit()
    else:
        if OPTIONS.host:
            print '#     %*s -> %*s#' %(-20, 'XNAT Host', -33, get_proper_str(OPTIONS.host))
        if OPTIONS.username:
            print '#     %*s -> %*s#' %(-20, 'XNAT User', -33, get_proper_str(OPTIONS.username))
        if OPTIONS.printmodality:
            print '#     %*s -> %*s#' %(-20, 'Print Modality', -33, 'on')
        else:
            if OPTIONS.csvfile:
                print '#     %*s -> %*s#' %(-20, 'CSV file', -33, get_proper_str(OPTIONS.csvfile))
            if OPTIONS.session_type:
                print '#     %*s -> %*s#' %(-20, 'Session Type', -33, get_proper_str(OPTIONS.session_type))
            if OPTIONS.report:
                print '#     %*s -> %*s#' %(-20, 'Report', -33, 'on')
            if OPTIONS.force:
                print '#     %*s -> %*s#' %(-20, 'Force Upload', -33, 'on')
            if OPTIONS.delete:
                print '#     %*s -> %*s#' %(-20, 'Delete resources', -33, 'on')
            if OPTIONS.deleteAll:
                print '#     %*s -> %*s#' %(-20, 'Delete All', -33, 'on')
            if OPTIONS.outputfile:
                print '#     %*s -> %*s#' %(-20, 'Output file', -33, get_proper_str(OPTIONS.outputfile))
        print '################################################################'
        print "IMPORTANT WARNING FOR ALL USERS ABOUT XNAT:"
        print "   session_label needs to be unique for each session."
        print "   Two subjects can NOT have the same session_label"
        print '================================================================'

def get_proper_str(str_option, end=False):
    """
    Method to shorten a string into the proper size for display

    :param str_option: string to shorten
    :param end: keep the end of the string visible (default beginning)
    :return: shortened string
    """
    if len(str_option) > 32:
        if end:
            return '...'+str_option[-29:]
        else:
            return str_option[:29]+'...'
    else:
        return str_option

def parse_args():
    """
    Method to parse arguments base on OptionParser

    :return: parser object
    """
    from argparse import ArgumentParser, RawTextHelpFormatter
    parser = ArgumentParser(prog='Xnatcheck', description=DESCRIPTION,
                            formatter_class=RawTextHelpFormatter)
    parser.add_argument('--host', dest='host', default=None,
                        help='Host for XNAT. Default: using $XNAT_HOST.')
    parser.add_argument('-u', '--username', dest='username', default=None,
                        help='Username for XNAT. Default: using $XNAT_USER.')
    #text file for report
    parser.add_argument("-c", "--csv", dest="csvfile", default=None,
                        help="CSV file with the information for uploading data to XNAT. Columns: object_type,project_id,subject_label,session_type,session_label,as_label,as_type,as_description,quality,resource,fpath.")
    #Verbose
    parser.add_argument("--sess", dest="session_type", default=None,
                        help="Session type on Xnat. Choices : use printmodality to see the options.")
    #Report
    parser.add_argument("--report", dest="report",action="store_true",
                        help="Gives a report of your upload from the csv.")
    #Force the uploading (meaning delete the resources if it already exists
    parser.add_argument("--force", dest="force", action="store_true",
                        help="Force the upload. If the resources exist, it will remove them before uploading.")
    #Delete resource before upload / delete all to delete all resources
    parser.add_argument("--delete", dest="delete", action="store_true",
                        help="Delete resources prior to upload.")
    parser.add_argument("--deleteAll", dest="deleteAll", action="store_true",
                        help="Delete all resources in the scan or assessor prior to upload.")
    #Possible modality
    parser.add_argument("--printmodality", dest="printmodality", action="store_true",
                        help="Display the different modality available with XNAT for a session.")
    parser.add_argument("-o","--output", dest="outputfile", default=None,
                        help="Filepath where the display of the upload will be printed.")
    return parser

########### MAIN FUNCTION ###########
if __name__ == '__main__':
    PARSER = parse_args()
    OPTIONS = PARSER.parse_args()
    main_display()
    SHOULD_RUN = check_options()
    LOGGER = setup_info_logger('xnatupload')

    if SHOULD_RUN:
        if OPTIONS.printmodality:
            print_modality()
        elif OPTIONS.report:
            print_report()
        else:
            # Connection to Xnat
            try:
                if OPTIONS.host:
                    HOST = OPTIONS.host
                else:
                    HOST = os.environ['XNAT_HOST']
                if OPTIONS.username:
                    MSG = "Please provide the password for user <%s> on xnat(%s):" % (OPTIONS.username, HOST)
                    PWD = getpass.getpass(prompt=MSG)
                else:
                    PWD = None

                print 'INFO: connection to xnat <%s>:' % (HOST)
                XNAT = XnatUtils.get_interface(host=OPTIONS.host, user=OPTIONS.username, pwd=PWD)
                #read csv:
                SCANS, ASSESSORS = read_csv_for_upload()
                upload_data_xnat()
            finally:
                XNAT.disconnect()

        LOGGER.info('===================================================================')
